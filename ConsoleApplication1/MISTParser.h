#pragma once
#include "Statistic.h"
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <cstdio>
#include <algorithm> 
#include <functional> 
#include <cctype>
#include <locale>
#include <regex>
#include <map>

using namespace std;

class MISTParser {
	private :
	string MISTFilename;
	string FASTAFileName;

	ifstream myReadFile;
	ofstream myWriteFile;

	map<string, int> opcodeCount;

	map<string, Statistic*>* pstats;

	map<string, char> opcodeToChar{
		//COMMON SYSCALL
		{"10 02",'A'}, //1. VM Protect
		{"03 07",'B'}, //2. Find File
		{"09 02",'C'}, //3. Open Key
		{"09 05",'D'}, //4. Query value
		{"03 03",'E'}, //5. Open file
		{"09 04",'F'}, //6. Set Value
		{"09 01",'G'}, //7. Create key
		{"0d 01",'H'}, //8. Get system directory

		//ALLAPLE SYSCALL
		{"04 01",'I'}, //9. PING
		{"03 0b",'J'}, //19. Set file attributes
		{"12 05",'K'}, //`11. Create socket
		{"12 0a",'L'}, //`12. Connect socket
		{"11 02",'M'}, //13. Enum Window
		{"11 04",'N'}, //14. Create window
		{"14 01",'M'} //15. Set windows hook
	};

	void writeFASTA(string sequenceName,vector<string>* opcodes) {
		if (!myWriteFile.is_open()) {
			myWriteFile.open(this->FASTAFileName);
			myWriteFile << ">" << sequenceName << endl;
		}
		//myWriteFile << ">" << sequenceName << endl;
		for (vector<string>::iterator it = opcodes->begin(); it != opcodes->end(); ++it) {
			if(opcodeToChar.find(*it) != opcodeToChar.end())
				myWriteFile << opcodeToChar[*it];
		}
		//myWriteFile << endl;
	}

	//Statistic for each file
	void writeStatistic() {
		//Write statistic
		//myWriteFile << "Operation Code Statistics" << endl;
		vector<pair<int, string>> tempver;
		for (map<string, int>::iterator it = opcodeCount.begin(); it != opcodeCount.end(); it++) {
			tempver.push_back(pair<int, string>(it->second, it->first));
			
			////Global Statistic
			if (pstats->find(it->first) != pstats->end()) {
				(*pstats)[it->first]->updateBound(it->second);
			}
			else {
				Statistic* s = new Statistic(it->first);
				s->updateBound(it->second);
				(*pstats)[it->first] = s;
			}
		}

		////Print pstats
		//for (map<string, Statistic*>::iterator it = pstats->begin(); it != pstats->end(); it++) {
		//	cout << (*it).first << "||" << (*it).second->getCode() << endl;
		//}

		//sort value
		//sort(tempver.begin(), tempver.end(), [=](std::pair<int, string>& a, std::pair<int, string>& b)
		//{
		//	return a.first > b.first;
		//});

		//for (vector<pair<int, string>>::iterator it = tempver.begin(); it != tempver.end(); ++it) {
		//	myWriteFile << (*it).second << "|" << (*it).first << endl;
		//}
	}


	bool isSeqEmpty(vector<string>* opcodes) {
		int count = 0;
		for (vector<string>::iterator it = opcodes->begin(); it != opcodes->end(); it++) {
			//The string is writeable
			if (opcodeToChar.find(*it)!=opcodeToChar.end()) count++;
		}
	
		if (count > 0) {
			return false;
		}
		else {
			return true;
		}
	}


	public :
		void info() {
			cout << MISTFilename << "||" << FASTAFileName << endl;
		}

		MISTParser(string infile, string outfile, map<string, Statistic*>* s) : MISTFilename(infile), FASTAFileName(outfile) {
			myReadFile.open(this->MISTFilename);
			pstats = s;
		}

		void parsing() {
			size_t psize = sizeof("# process");
			size_t tsize = sizeof("thread");
			string sequenceName;
			vector<string> opcodes;

			if (myReadFile.is_open()) {
				for (std::string line; getline(myReadFile, line); ) {
					size_t pridx = line.find("# process");
					if (pridx != std::string::npos) {

						//Write Previous opcodes to fasta file
						if (!opcodes.empty()) {
							if(!isSeqEmpty(&opcodes)) writeFASTA(sequenceName, &opcodes);
							opcodes.clear();
							sequenceName = "";
						}

						size_t tidx = line.find("thread");
						size_t endidx = line.find_last_of("#");

						//Get Thread and Process Id
						pridx += psize;
						string phex = line.substr(pridx, tidx - pridx - 1);
						phex.append("-");
						//cout << phex << endl;

						tidx += tsize;
						string thex = line.substr(tidx, endidx - tidx - 1);
						//cout <<  thex << "#" << endl;

						//sequenceName.append(phex);
						//sequenceName.append(thex);
						//sequenceName.erase(remove_if(sequenceName.begin(), sequenceName.end(), isspace),sequenceName.end());

						int dash = FASTAFileName.find('/');
						int dot = FASTAFileName.find('.');
						sequenceName = FASTAFileName.substr(dash+1,dot-dash-1);
						
					}
					else {
						//Get Operation Code
						size_t opidx = line.find_first_of("|");
						//cout << "Operation code:" << line.substr(0, opidx - 1);
						string opcode = line.substr(0, opidx - 1);
						opcodes.push_back(opcode);
						
						//Local Statistic
						if(opcodeCount.find(opcode) != opcodeCount.end())
							opcodeCount[opcode]++;
						else opcodeCount[opcode] = 1;
					}

					//char temp; cin >> temp;
				}

				//Write last process opcodes to fasta file
				if (!opcodes.empty()) {
					if (!isSeqEmpty(&opcodes)) writeFASTA(sequenceName,&opcodes);
					opcodes.clear();
				}

				myWriteFile << endl;

				writeStatistic();

				myReadFile.close();
				myWriteFile.close();
			}
			else {
				cout << "File is not open" << endl;
			}
		}
};