#include "stdafx.h"
#include <easyhook.h>
#include <string>
#include <iostream>
#include <Windows.h>
#include <Tlhelp32.h>
#include <vector>
#include <fstream>
#include <tchar.h>
#include <WinSock2.h>
#include <map>
#include <iphlpapi.h>
#include <icmpapi.h>
#include <Shlwapi.h>

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "Shlwapi.lib")

#define BUFSIZE MAX_PATH

using namespace std;

DWORD gFreqOffset = 0;
TCHAR* outputfile = TEXT("\\Device\\HarddiskVolume2\\Users\\win-7-32\\Desktop\\malware_analysis\\Debug\\api-hooked\\");
TCHAR* dllToInject = TEXT("BeepHook.dll");

ofstream myfile;
map<string, char> funcNameToChar{
	//COMMON SYSCALL
	{ "myVirtualProtect",'A' }, //1. VM Protect
	{ "myFindFile",'B' }, //2. Find File
	{ "myRegOpenKeyEx",'C' }, //3. Open Key
	{ "myRegQueryValueEx",'D' }, //4. Query value
	{ "myOpenFile",'E' }, //5. Open file
	{ "myRegSetValueEx",'F' }, //6. Set Value
	{ "myRegCreateKeyEx",'G' }, //7. Create key
	{ "myGetSystemDirectory",'H' }, //8. Get system directory

	//ALLAPLE SYSCALL
	{ "myIcmpSendEcho",'I' }, //9. PING
	{ "mySetFileAttributes",'J' }, //19. Set file attributes
	{ "mysocket",'K' }, //`11. Create socket
	{ "myconnect",'L' }, //`12. Connect socket
	{ "myEnumWindows",'M' }, //13. Enum Window
	{ "myCreateWindowEx",'N' }, //14. Create window
	{ "mySetWindowsHookEx",'O' }, //15. Set windows hook
	{ "mySleep",'P'}
};

void TryOpenFile() {
	if (!myfile.is_open()) {
		//Create filename
		char exename[1024];
		char filename[1024];
		TCHAR buffer[MAX_PATH] = { 0 };
		TCHAR * out;
		DWORD bufSize = sizeof(buffer) / sizeof(*buffer);
		if (GetModuleFileName(NULL, buffer, bufSize) == bufSize)
		{
			// the buffer is too small, handle the error somehow
			printf("Namanya panjang banget boo~~~\n");
			return;
		}
		out = PathFindFileName(buffer);
		*(PathFindExtension(out)) = 0;
		size_t charsConverted = 0;
		wcstombs_s(&charsConverted, exename, out, wcslen(out) + 1);
		sprintf_s(filename, "C:\\Users\\win-7-32\\Desktop\\malware_analysis\\Debug\\api-hooked\\%s-%d.out", exename, GetCurrentProcessId());
		myfile.open(filename, ofstream::out | ofstream::trunc);
		//char toWrite[1024];
		//sprintf_s(toWrite, ">%s-%d\n", exename, GetCurrentProcessId());
		//myfile.write(toWrite, sizeof(toWrite));
		myfile << ">" << exename << "-" << GetCurrentProcessId() << endl;
		myfile.flush();
	}
}

BOOL WINAPI myVirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect) {
	TryOpenFile();
	//cout << funcNameToChar["myVirtualProtect"];
	myfile << funcNameToChar["myVirtualProtect"] ;
	myfile.flush();
	return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

HANDLE WINAPI myCreateFileW(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes, HANDLE hTemplateFile) {
	TryOpenFile();
	
	//if (!_tcsstr(lpFileName, outputfile)) {
	//}

	if (dwDesiredAccess == 0) {
		//cout << funcNameToChar["myFindFile"];
		myfile << funcNameToChar["myFindFile"];
	}
	else {
		//cout << funcNameToChar["myOpenFile"];
		myfile << funcNameToChar["myOpenFile"];
	}
	myfile.flush();
	return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
		dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HANDLE WINAPI myCreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes, HANDLE hTemplateFile) {
	TryOpenFile();

	if (dwDesiredAccess == 0) {
		//cout << funcNameToChar["myFindFile"];
		myfile << funcNameToChar["myFindFile"];
	}
	else {
		//cout << funcNameToChar["myOpenFile"];
		myfile << funcNameToChar["myOpenFile"];
	}
	myfile.flush();
	return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
		dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

LONG WINAPI myRegOpenKeyExW(HKEY hkey, LPCTSTR lpSubKey, DWORD ulOptions, 
	REGSAM samDesired, PHKEY phkResult) {
	TryOpenFile();
	//cout << funcNameToChar["myRegOpenKeyEx"];
	myfile << funcNameToChar["myRegOpenKeyEx"] ;
	myfile.flush();
	return RegOpenKeyExW(hkey, lpSubKey, ulOptions, samDesired, phkResult);
}

LONG WINAPI myRegOpenKeyExA(HKEY hkey, LPCSTR lpSubKey, DWORD ulOptions,
	REGSAM samDesired, PHKEY phkResult) {
	TryOpenFile();
	//cout << funcNameToChar["myRegOpenKeyEx"];
	myfile << funcNameToChar["myRegOpenKeyEx"] ;
	myfile.flush();
	return RegOpenKeyExA(hkey, lpSubKey, ulOptions, samDesired, phkResult);
}

LONG WINAPI myRegQueryValueExW(HKEY hkey, LPCTSTR lpValueName, LPDWORD lpReserved,
	LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) {
	TryOpenFile();
	//cout << funcNameToChar["myRegQueryValueEx"];
	myfile << funcNameToChar["myRegQueryValueEx"] ;
	myfile.flush();
	return RegQueryValueExW(hkey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}

LONG WINAPI myRegQueryValueExA(HKEY hkey, LPCSTR lpValueName, LPDWORD lpReserved,
	LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) {
	TryOpenFile();
	//cout << funcNameToChar["myRegQueryValueEx"];
	myfile << funcNameToChar["myRegQueryValueEx"] ;
	myfile.flush();
	return RegQueryValueExA(hkey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}

LONG WINAPI myRegSetValueExW(HKEY hKey, LPCTSTR lpValueName, DWORD reserved,
	DWORD dwType, const BYTE* lpData, DWORD cbData) {
	TryOpenFile();
	//cout << funcNameToChar["myRegSetValueEx"];
	myfile << funcNameToChar["myRegSetValueEx"] ;
	myfile.flush();
	return RegSetValueExW(hKey, lpValueName, reserved, dwType, lpData, cbData);
}

LONG WINAPI myRegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD reserved,
	DWORD dwType, const BYTE* lpData, DWORD cbData) {
	TryOpenFile();
	//cout << funcNameToChar["myRegSetValueEx"];
	myfile << funcNameToChar["myRegSetValueEx"] ;
	myfile.flush();
	return RegSetValueExA(hKey, lpValueName, reserved, dwType, lpData, cbData);
}

LONG WINAPI myRegCreateKeyExW(HKEY hKey,LPCTSTR lpSubKey,DWORD Reserved,
	LPTSTR lpClass,DWORD  dwOptions,REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,PHKEY phkResult,
	LPDWORD lpdwDisposition)
{
	TryOpenFile();
	//cout << funcNameToChar["myRegCreateKeyEx"];
	myfile << funcNameToChar["myRegCreateKeyEx"] ;
	myfile.flush();
	return RegCreateKeyExW(hKey, lpSubKey, Reserved,
		lpClass, dwOptions, samDesired,
		lpSecurityAttributes, phkResult,
		lpdwDisposition);

}

LONG WINAPI myRegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved,
	LPSTR lpClass, DWORD  dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult,
	LPDWORD lpdwDisposition)
{
	TryOpenFile();
	//cout << funcNameToChar["myRegCreateKeyEx"];
	myfile << funcNameToChar["myRegCreateKeyEx"] ;
	myfile.flush();
	return RegCreateKeyExA(hKey, lpSubKey, Reserved,
		lpClass, dwOptions, samDesired,
		lpSecurityAttributes, phkResult,
		lpdwDisposition);

}

UINT WINAPI myGetSystemDirectoryW(LPTSTR lpBuffer, UINT uSize) {
	TryOpenFile();
	//cout << funcNameToChar["myGetSystemDirectory"];
	myfile << funcNameToChar["myGetSystemDirectory"] ;
	myfile.flush();
	return GetSystemDirectoryW(lpBuffer, uSize);
}

UINT WINAPI myGetSystemDirectoryA(LPSTR lpBuffer, UINT uSize) {
	TryOpenFile();
	//cout << funcNameToChar["myGetSystemDirectory"];
	myfile << funcNameToChar["myGetSystemDirectory"] ;
	myfile.flush();
	return GetSystemDirectoryA(lpBuffer, uSize);
}

DWORD myIcmpSendEcho(HANDLE IcmpHandle,IPAddr DestAddr,LPVOID RequestData,
	WORD RequestSize,PIP_OPTION_INFORMATION RequestOptions,
	LPVOID ReplyBuffer,DWORD ReplySize,DWORD Timeout) {
	TryOpenFile();
	//cout << funcNameToChar["myIcmpSendEcho"];
	myfile << funcNameToChar["myIcmpSendEcho"] ;
	myfile.flush();
	return IcmpSendEcho(IcmpHandle, DestAddr, RequestData,
		RequestSize, RequestOptions, ReplyBuffer, ReplySize, Timeout);
}
//myIcmpSendEcho2
//myIcmpSendEcho2Ex

BOOL WINAPI mySetFileAttributesW(LPCTSTR lpFileName, DWORD dwFileAttributes) {
	TryOpenFile();
	//cout << funcNameToChar["mySetFileAttributes"];
	myfile << funcNameToChar["mySetFileAttributes"] ;
	myfile.flush();
	return SetFileAttributesW(lpFileName, dwFileAttributes);
}

BOOL WINAPI mySetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes) {
	TryOpenFile();
	//cout << funcNameToChar["mySetFileAttributes"];
	myfile << funcNameToChar["mySetFileAttributes"] ;
	myfile.flush();
	return SetFileAttributesA(lpFileName, dwFileAttributes);
}

SOCKET WSAAPI mysocket(int af, int type, int protocol) {
	TryOpenFile();
	//cout << funcNameToChar["mysocket"];
	myfile << funcNameToChar["mysocket"] ;
	myfile.flush();
	return socket(af, type, protocol);
}

int myconnect(SOCKET s, const struct sockaddr* name, int namelen) {
	TryOpenFile();
	//cout << funcNameToChar["myconnect"];
	myfile << funcNameToChar["myconnect"] ;
	myfile.flush();
	return connect(s, name, namelen);
}

BOOL WINAPI myEnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam) {
	TryOpenFile();
	//cout << funcNameToChar["myEnumWindows"];
	myfile << funcNameToChar["myEnumWindows"] ;
	myfile.flush();
	return EnumWindows(lpEnumFunc, lParam);
}

HWND WINAPI myCreateWindowExW(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, 
	DWORD dwStyle,int x, int y, int nWidth, int nHeight, HWND hWndParent, 
	HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam) {
	TryOpenFile();
	//cout << funcNameToChar["myCreateWindowEx"];
	myfile << funcNameToChar["myCreateWindowEx"] ;
	myfile.flush();
	return CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);

}

HWND WINAPI myCreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName,
	DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent,
	HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam) {
	TryOpenFile();
	//cout << funcNameToChar["myCreateWindowEx"];
	myfile << funcNameToChar["myCreateWindowEx"] ;
	myfile.flush();
	return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);

}

HHOOK WINAPI mySetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId) {
	TryOpenFile();
	//cout << funcNameToChar["mySetWindowsHookEx"];
	myfile << funcNameToChar["mySetWindowsHookEx"] ;
	myfile.flush();
	return SetWindowsHookExW(idHook, lpfn, hMod, dwThreadId);
}

HHOOK WINAPI mySetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId) {
	TryOpenFile();
	//cout << funcNameToChar["mySetWindowsHookEx"];
	myfile << funcNameToChar["mySetWindowsHookEx"] ;
	myfile.flush();
	return SetWindowsHookExA(idHook, lpfn, hMod, dwThreadId);
}

BOOL WINAPI myCreateProcessW(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags,
	LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation
) {
	BOOL result = CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles,
		dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

	printf("%lu created child with id: %lu \n", GetCurrentProcessId(), lpProcessInformation->dwProcessId);

	//NTSTATUS nt = RhInjectLibrary(
	//	lpProcessInformation->dwProcessId,   // The process to inject into
	//	0,           // ThreadId to wake up upon injection
	//	EASYHOOK_INJECT_DEFAULT,
	//	dllToInject, // 32-bit
	//	NULL,		 // 64-bit not provided
	//	NULL, // data to send to injected DLL entry point
	//	0// size of data to send
	//);

	//if (nt != 0)
	//{
	//	printf("RhInjectLibrary failed with error code = %d\n", nt);
	//	PWCHAR err = RtlGetLastErrorString();
	//	std::w//cout << err << "\n";
	//}
	//else
	//{
	//	std::w//cout << L"Library injected successfully.\n";
	//}

	return result;
}

BOOL WINAPI myCreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags,
	LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation
) {
	BOOL result = CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles,
		dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
	printf("Child process with id: %lu created", lpProcessInformation->dwProcessId);

	return result;
}

VOID WINAPI mySleep(DWORD dwMilliseconds) {
	TryOpenFile();
	//cout << funcNameToChar["mySleep"];
	myfile << funcNameToChar["mySleep"] << dwMilliseconds << endl;
	myfile.flush();
	Sleep(dwMilliseconds);
}

extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo);
void __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo) {
	vector<HOOK_TRACE_INFO> hHooks(30, { NULL });
	vector<NTSTATUS> hookStats;
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "VirtualProtect"),
		myVirtualProtect, NULL, &hHooks[0]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateFileW"),
		myCreateFileW, NULL, &hHooks[1]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateFileA"),
		myCreateFileA, NULL, &hHooks[2]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegOpenKeyExW"),
		myRegOpenKeyExW, NULL, &hHooks[3]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegOpenKeyExA"),
		myRegOpenKeyExA, NULL, &hHooks[4]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegQueryValueExW"),
		myRegQueryValueExW, NULL, &hHooks[5]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegQueryValueExA"),
		myRegQueryValueExA, NULL, &hHooks[6]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegSetValueExW"),
		myRegSetValueExW, NULL, &hHooks[7]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegSetValueExA"),
		myRegSetValueExA, NULL, &hHooks[8]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegCreateKeyExW"),
		myRegCreateKeyExW, NULL, &hHooks[9]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("advapi32.dll")), "RegCreateKeyExA"),
		myRegCreateKeyExA, NULL, &hHooks[10]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetSystemDirectoryW"),
		myGetSystemDirectoryW, NULL, &hHooks[11]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetSystemDirectoryA"),
		myGetSystemDirectoryA, NULL, &hHooks[12]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("iphlpapi.dll")), "IcmpSendEcho"),
		myIcmpSendEcho, NULL, &hHooks[13]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "SetFileAttributesW"),
		mySetFileAttributesW, NULL, &hHooks[14]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "SetFileAttributesA"),
		mySetFileAttributesA, NULL, &hHooks[15]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("ws2_32.dll")), "socket"),
		mysocket, NULL, &hHooks[16]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("ws2_32.dll")), "connect"),
		myconnect, NULL, &hHooks[17]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("user32.dll")), "EnumWindows"),
		myEnumWindows, NULL, &hHooks[18]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("user32.dll")), "CreateWindowExW"),
		myCreateWindowExW, NULL, &hHooks[19]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("user32.dll")), "CreateWindowExA"),
		myCreateWindowExA, NULL, &hHooks[20]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("user32.dll")), "SetWindowsHookExW"),
		mySetWindowsHookExW, NULL, &hHooks[21]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("user32.dll")), "SetWindowsHookExA"),
		mySetWindowsHookExA, NULL, &hHooks[22]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateProcessW"),
		myCreateProcessW, NULL, &hHooks[23]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateProcessA"),
		myCreateProcessA, NULL, &hHooks[24]));
	hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "Sleep"),
		mySleep, NULL, &hHooks[25]));

	vector<NTSTATUS>::iterator it;
	bool failed = false;
	for (it = hookStats.begin(); it != hookStats.end(); it++) {
		if (FAILED(*it)) failed = true;
	}
	if (failed) {
		wstring(s);
		//cout << "NativeInjectionEntryPoint: Failed to install hook :" << s << endl ;
	}
	else {
		//cout << "NativeInjectionEntryPoint: Hook 'myBeepHook installed successfully." << endl;
	}
	ULONG ACLEntries[1] = { 0 };
	for (int i = 0; i <= 25 ; i++) {
		LhSetExclusiveACL(ACLEntries, 1, &hHooks[i]);
	}
	RhWakeUpProcess();
}