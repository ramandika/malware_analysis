// BeepHook.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"

#include <easyhook.h>
#include <string>
#include <iostream>
#include <Windows.h>
#include <vector>
#include <fstream>
using namespace std;
DWORD gFreqOffset = 0;
ofstream myfile;


BOOL WINAPI myBeepHook(DWORD dwFreq, DWORD dwDuration)
{
	cout << "Beep" << endl;
	return Beep(dwFreq + gFreqOffset, dwDuration);
}

DWORD WINAPI myMessageBox(HWND hwnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) {
	cout << "MessageBox" << endl;
	int msgboxID = MessageBox(
		hwnd,
		lpText,
		lpCaption,
		uType
	);
	return msgboxID;
}

//Kernel32.dll
BOOL WINAPI myMoveFileEx(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, DWORD dwFlags) {
	cout << "myMoveFileEx" << endl;
	return MoveFileEx(lpExistingFileName, lpNewFileName, dwFlags);
}
BOOL WINAPI myReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped) {
	cout << "myReadFile" << endl;
	return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}
BOOL WINAPI myWriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped) {
	cout << "myWriteFile" << endl;
	return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}
DWORD WINAPI mySetFilePointer(HANDLE hFile, LONG   lDistanceToMove, PLONG  lpDistanceToMoveHigh, DWORD  dwMoveMethod) {
	cout << "mySetFilePointer" << endl;
	return SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
}

BOOL WINAPI myFindClose(HANDLE hFile) {
	cout << "myFindClose" << endl;
	return FindClose(hFile);
}
HANDLE WINAPI myFindFirstFile(LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData) {
	cout << "myFindFirstFile" << endl;
	return FindFirstFile(lpFileName,lpFindFileData);
}
BOOL WINAPI myDeleteFile(LPCTSTR lpFileName) {
	cout << "myDeleteFile" << endl;
	return DeleteFile(lpFileName);
}
HANDLE WINAPI myCreateFile(
	LPCTSTR lpFileName,
	DWORD dwDesiredAccess,
	DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes, HANDLE hTemplateFile) {
	cout << "myCreateFile" << endl;
	return CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

}

// EasyHook will be looking for this export to support DLL injection. If not found then 
// DLL injection will fail.
extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo);

void __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo)
{
	cout << "\n\nNativeInjectionEntryPointt(REMOTE_ENTRY_INFO* inRemoteInfo)\n\n" <<
		"IIIII           jjj               tt                dd !!! \n"
		" III  nn nnn          eee    cccc tt      eee       dd !!! \n"
		" III  nnn  nn   jjj ee   e cc     tttt  ee   e  dddddd !!! \n"
		" III  nn   nn   jjj eeeee  cc     tt    eeeee  dd   dd     \n"
		"IIIII nn   nn   jjj  eeeee  ccccc  tttt  eeeee  dddddd !!! \n"
		"              jjjj                                         \n\n";

	cout << "NativeInjectionEntryPoint: Injected by process Id: " << inRemoteInfo->HostPID << "\n";
	cout << "NativeInjectionEntryPoint: Passed in data size: " << inRemoteInfo->UserDataSize << "\n" ;
	if (inRemoteInfo->UserDataSize == sizeof(DWORD))
	{
		gFreqOffset = *reinterpret_cast<DWORD *>(inRemoteInfo->UserData);
		cout << "NativeInjectionEntryPoint: Adjusting Beep frequency by: " << gFreqOffset << "\n";
	}

	// Perform hooking
	//HOOK_TRACE_INFO hHook = { NULL }; // keep track of our hook
	vector<HOOK_TRACE_INFO> hHooks(8, { NULL });

	//cout << "\n";
	//cout << "NativeInjectionEntryPoint: Win32 Beep found at address: " << GetProcAddress(GetModuleHandle(TEXT("kernel32")), "Beep") << "\n";
	//cout << "NativeInjectionEntryPoint: User32 MessageBox found at address: " << GetProcAddress(GetModuleHandle(TEXT("user32")), "MessageBeep") << "\n";

	// Install the hook
	NTSTATUS result = LhInstallHook(
		GetProcAddress(GetModuleHandle(TEXT("kernel32")), "MoveFileExW"),
		myMoveFileEx,
		NULL,
		&hHooks[0]) && LhInstallHook(
			GetProcAddress(GetModuleHandle(TEXT("kernel32")), "ReadFile"),
			myReadFile,
			NULL,
			&hHooks[1]) && LhInstallHook(
				GetProcAddress(GetModuleHandle(TEXT("kernel32")), "WriteFile"),
				myWriteFile,
				NULL,
				&hHooks[2]) && LhInstallHook(
					GetProcAddress(GetModuleHandle(TEXT("kernel32")), "SetFilePointer"),
					SetFilePointer,
					NULL,
					&hHooks[3]) && LhInstallHook(
						GetProcAddress(GetModuleHandle(TEXT("kernel32")), "FindClose"),
						myFindClose,
						NULL,
						&hHooks[4]) && LhInstallHook(
							GetProcAddress(GetModuleHandle(TEXT("kernel32")), "FindFirstFileW"),
							myFindFirstFile,
							NULL,
							&hHooks[5]) && LhInstallHook(
								GetProcAddress(GetModuleHandle(TEXT("kernel32")), "DeleteFileW"),
								myDeleteFile,
								NULL,
								&hHooks[6]) && LhInstallHook(
									GetProcAddress(GetModuleHandle(TEXT("kernel32")), "CreateFileW"),
									myCreateFile,
									NULL,
									&hHooks[7]);

	if (FAILED(result))
	{
		wstring s(RtlGetLastErrorString());
		wcout << "NativeInjectionEntryPoint: Failed to install hook: " << s << "\n";
	}
	else 
	{
		cout << "NativeInjectionEntryPoint: Hook 'myBeepHook installed successfully.\n";
	}

	// If the threadId in the ACL is set to 0,
	// then internally EasyHook uses GetCurrentThreadId()
	ULONG ACLEntries[1] = { 0 };

	// Disable the hook for the provided threadIds, enable for all others
	vector<HOOK_TRACE_INFO>::iterator it;
	for (it = hHooks.begin(); it != hHooks.end(); it++) {
		LhSetExclusiveACL(ACLEntries, 1, &*it);
	}

	RhWakeUpProcess();
	cout << "Process wake up" << endl;
	return;
}
