// BeepHook.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"

#include <easyhook.h>
#include <string>
#include <iostream>
#include <Windows.h>
#include <vector>
#include <fstream>
using namespace std;
DWORD gFreqOffset = 0;
ofstream myfile;


BOOL WINAPI myBeepHook(DWORD dwFreq, DWORD dwDuration)
{
	cout << "Beep" << endl;
	return Beep(dwFreq + gFreqOffset, dwDuration);
}

DWORD WINAPI myMessageBox(HWND hwnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) {
	cout << "MessageBox" << endl;
	int msgboxID = MessageBox(
		hwnd,
		lpText,
		lpCaption,
		uType
	);
	return msgboxID;
}

VOID WINAPI myFunctionHook() {
	cout << "MessageBox1" << endl;
	cout << "MessageBox2" << endl;
}

// EasyHook will be looking for this export to support DLL injection. If not found then 
// DLL injection will fail.
extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo);

void __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo)
{
	myfile.open("api_seq.txt");

	cout << "\n\nNativeInjectionEntryPointt(REMOTE_ENTRY_INFO* inRemoteInfo)\n\n" <<
		"IIIII           jjj               tt                dd !!! \n"
		" III  nn nnn          eee    cccc tt      eee       dd !!! \n"
		" III  nnn  nn   jjj ee   e cc     tttt  ee   e  dddddd !!! \n"
		" III  nn   nn   jjj eeeee  cc     tt    eeeee  dd   dd     \n"
		"IIIII nn   nn   jjj  eeeee  ccccc  tttt  eeeee  dddddd !!! \n"
		"              jjjj                                         \n\n";

	cout << "NativeInjectionEntryPoint: Injected by process Id: " << inRemoteInfo->HostPID << "\n";
	cout << "NativeInjectionEntryPoint: Passed in data size: " << inRemoteInfo->UserDataSize << "\n" ;
	if (inRemoteInfo->UserDataSize == sizeof(DWORD))
	{
		gFreqOffset = *reinterpret_cast<DWORD *>(inRemoteInfo->UserData);
		cout << "NativeInjectionEntryPoint: Adjusting Beep frequency by: " << gFreqOffset << "\n";
	}

	// Perform hooking
	//HOOK_TRACE_INFO hHook = { NULL }; // keep track of our hook
	vector<HOOK_TRACE_INFO> hHooks(2, { NULL });

	cout << "\n";
	cout << "NativeInjectionEntryPoint: Win32 Beep found at address: " << GetProcAddress(GetModuleHandle(TEXT("kernel32")), "Beep") << "\n";
	cout << "NativeInjectionEntryPoint: User32 MessageBox found at address: " << GetProcAddress(GetModuleHandle(TEXT("user32")), "MessageBeep") << "\n";

	// Install the hook
	NTSTATUS result = LhInstallHook(
		GetProcAddress(GetModuleHandle(TEXT("kernel32")), "Beep"),
		myFunctionHook,//myBeepHook,
		NULL,
		&hHooks[0]);
	NTSTATUS result1 = LhInstallHook(
		GetProcAddress(GetModuleHandle(TEXT("user32")), "MessageBoxW"),
		myFunctionHook,//myMessageBox,
		NULL,
		&hHooks[1]);

	if (FAILED(result) || FAILED(result1))
	{
		wstring s(RtlGetLastErrorString());
		wcout << "NativeInjectionEntryPoint: Failed to install hook: " << s << "\n";
	}
	else 
	{
		cout << "NativeInjectionEntryPoint: Hook 'myBeepHook installed successfully.\n";
	}

	// If the threadId in the ACL is set to 0,
	// then internally EasyHook uses GetCurrentThreadId()
	ULONG ACLEntries[1] = { 0 };

	// Disable the hook for the provided threadIds, enable for all others
	LhSetExclusiveACL(ACLEntries, 1, &hHooks[0]);
	LhSetExclusiveACL(ACLEntries, 1, &hHooks[1]);

	RhWakeUpProcess();
	cout << "Process wake up" << endl;
	return;
}
