#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <cstring>
#include "HookApi.h"
using namespace std;

class Writer {
private :
	string filename;
	vector<HookApi> apilist;
	ofstream wr;
	
public :
	Writer(vector<HookApi> input) {
		apilist = input;
		wr.open(this->filename); 
	}
	void writehook(string fo) {
		if (apilist.size() > 0) {
			string line;
			wr.open(fo);
			if (wr.is_open()) {
				vector<HookApi>::iterator it;
				vector<pair<string, string> > params;
				wr << "#include \"stdafx.h\"" << endl;
				wr << "#include <easyhook.h>" << endl;
				wr << "#include <string>" << endl;
				wr << "#include <iostream>" << endl;
				wr << "#include <Windows.h>" << endl;
				wr << "#include <Tlhelp32.h>" << endl;
				wr << "#include <vector>" << endl;
				wr << "#include <fstream>" << endl;
				wr << "#include <tchar.h>" << endl;
				wr << "#include <WinSock2.h>" << endl;
				wr << "#define BUFSIZE MAX_PATH" << endl;
				wr << "using namespace std;" << endl;
				wr << "DWORD gFreqOffset = 0;" << endl;
				wr << "ofstream myfile;" << endl;
				/**************Api Definition**************/
				for (it = apilist.begin(); it != apilist.end(); it++) {
					wr << it->getReturnType() << " " << "my"+it->getFuncName() << "(";
					params = it->getParams();
					for (int i = params.size()-1; i >=0 ; i--) {
						wr << params[i].first << " " << params[i].second;
						if (i > 0) wr << ",";
					}
					wr << "){" << endl;
					//
					wr << "\tcout << " << '"' << "my" + it->getFuncName() << "\" << endl;" << endl;
					if (it->getReturnType().find("void") != NULL) {
						wr << "\treturn" << " ";
					}
					wr << it->getFuncName() << "(";
					for (int i = params.size() - 1; i >= 0; i--) {
						wr << params[i].second;
						if (i > 0) wr << ",";
					}
					wr << ");" << endl;
					wr << "}" << endl;
				}
				/**************NativeEntrypPoint**************/
				wr << "extern \"C\" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo);" << endl;
				wr << "void __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO* inRemoteInfo){" << endl;
				wr << "vector<HOOK_TRACE_INFO> hHooks(" << apilist.size() << ", { NULL });" << endl;
				wr << "vector<NTSTATUS> hookStats;" << endl;
				//HookStats
				for (int i = 0; i<apilist.size(); i++) {
					wr << "hookStats.push_back(LhInstallHook(GetProcAddress(GetModuleHandle(TEXT(\"" << apilist[i].getModul() << "\")), \"" << apilist[i].getFuncName() << "\")," << "my"+apilist[i].getFuncName() << ",NULL,&hHooks[" << i << "]));" << endl;
				}
				//Hooking Check
				wr << "vector<NTSTATUS>::iterator it;" << endl;
				wr << "bool failed = false;" << endl;
				wr << "for (it = hookStats.begin(); it != hookStats.end(); it++) {\n if (FAILED(*it)) { failed = true;}\n}" << endl;
				wr << "if(failed)\n{\nwstring(s);\nwcout<< \"NativeInjectionEntryPoint: Failed to install hook :\" << s << endl;}";
				wr << "else\n{\ncout << \"NativeInjectionEntryPoint: Hook 'myBeepHook installed successfully.\" << endl;\n}\n";
				wr << "ULONG ACLEntries[1] = { 0 };" << endl;

				for (int i = 0; i < apilist.size();i++) {
					wr << "LhSetExclusiveACL(ACLEntries, 1, &hHooks[" << i << "]);" << endl;
				}
				wr << "RhWakeUpProcess();" << endl;
				wr << "}" << endl;
				/*********************************************/
			}
		}
		else {
			cout << "No procedure to be written" << endl;
		}
	}
};