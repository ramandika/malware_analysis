#include "stdafx.h"
#include <winsock2.h>
#include <Windows.h>
#include <iphlpapi.h>
#include <icmpapi.h>
#include <stdio.h>
#include <iostream>
#include <tchar.h>
#include <string>

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

int doPing()  {

    // Declare and initialize variables
    
    HANDLE hIcmpFile;
    unsigned long ipaddr = INADDR_NONE;
    DWORD dwRetVal = 0;
    char SendData[32] = "Data Buffer";
    LPVOID ReplyBuffer = NULL;
    DWORD ReplySize = 0;

    ipaddr = inet_addr("74.125.68.100");

    hIcmpFile = IcmpCreateFile();
    if (hIcmpFile == INVALID_HANDLE_VALUE) {
        printf("\tUnable to open handle.\n");
        printf("IcmpCreatefile returned error: %ld\n", GetLastError() );
        return 1;
    }    

    ReplySize = sizeof(ICMP_ECHO_REPLY) + sizeof(SendData);
    ReplyBuffer = (VOID*) malloc(ReplySize);
    if (ReplyBuffer == NULL) {
        printf("\tUnable to allocate memory\n");
        return 1;
    }    
    
	for (int i = 0; i < 10; i++) {
		dwRetVal = IcmpSendEcho(hIcmpFile, ipaddr, SendData, sizeof(SendData),
			NULL, ReplyBuffer, ReplySize, 1000);
		if (dwRetVal != 0) {
			PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY)ReplyBuffer;
			struct in_addr ReplyAddr;
			ReplyAddr.S_un.S_addr = pEchoReply->Address;
			//printf("\tSent icmp message to %s\n", "74.125.68.100");
			if (dwRetVal > 1) {
				//printf("\tReceived %ld icmp message responses\n", dwRetVal);
				//printf("\tInformation from the first response:\n");
			}
			else {
				//printf("\tReceived %ld icmp message response\n", dwRetVal);
				//printf("\tInformation from this response:\n");
			}
			//printf("\t  Received from %s\n", inet_ntoa(ReplyAddr));
			//printf("\t  Status = %ld\n",pEchoReply->Status);
			//printf("\t  Roundtrip time = %ld milliseconds\n",	pEchoReply->RoundTripTime);
		}
		else {
			//printf("\tCall to IcmpSendEcho failed.\n");
			//printf("\tIcmpSendEcho returned error: %ld\n", GetLastError());
			return 1;
		}
		Sleep(1000);
	}
	std::cout << std::endl << "Finish" << std::endl;
    return 0;
}    



//Returns the last Win32 error, in string format. Returns an empty string if there is no error.
std::string GetLastErrorAsString()
{
	//Get the error message, if any.
	DWORD errorMessageID = ::GetLastError();
	if (errorMessageID == 0)
		return std::string(); //No error message has been recorded

	LPSTR messageBuffer = nullptr;
	size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

	std::string message(messageBuffer, size);

	//Free the buffer.
	LocalFree(messageBuffer);

	return message;
}

void _tmain(int argc, TCHAR *argv[])
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	
	wchar_t command[1024] = L"ping facebook.com -t";

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	//if (argc != 2)
	//{
	//	std::wcout << "Usage: " << argv[0] << " [cmdline]\n" << std::endl;
	//	return;
	//}

	//std::wcout << "Command: " << argv[1] << std::endl;

	Sleep(5000);
	//printf("Main process id: %lu, sleep for a little while\n", GetCurrentProcessId());

	Sleep(5000);

	doPing();

	////// Start the child process. 
	//if (!CreateProcess(NULL,   // No module name (use command line)
	//	command,        // Command line
	//	NULL,           // Process handle not inheritable
	//	NULL,           // Thread handle not inheritable
	//	FALSE,          // Set handle inheritance to FALSE
	//	0,              // No creation flags
	//	NULL,           // Use parent's environment block
	//	NULL,           // Use parent's starting directory 
	//	&si,            // Pointer to STARTUPINFO structure
	//	&pi)           // Pointer to PROCESS_INFORMATION structure
	//	)
	//{
	//	std::cout << GetLastErrorAsString() << std::endl;
	//	return;
	//}


	//// Wait until child process exits.
	//WaitForSingleObject(pi.hProcess, INFINITE);

	//// Close process and thread handles. 
	//CloseHandle(pi.hProcess);
	//CloseHandle(pi.hThread);
}